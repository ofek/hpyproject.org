var tipuesearch = {
  "pages": [
    {
      "title": "HPy Sprint Status Update and Feedback Session",
      "text": "As we announced in\nthis blog post,\nwe are currently having our joint PyPy/HPy/GraalPy sprint in D\u00fcsseldorf.\nOn Thursday (September 22nd, 2022), we did the HPy sprint report. Most notably,\nwe also had several CPython core developers in the call.\nThe sprint report was streamed on\nTwitch and the recording is available here:\n\n\n\nHPy Sprint Call with CPython Core Developers\nOne of the main goals in the sprint was to write a PEP to officially propose\nHPy as an Python C extension API. We started to do so but before we actually\nsubmit this PEP, we wanted to have some feedback. So, we invited the Python\ncore developers to our call and some of them joined.\nWe gave a short overview of HPy since not everyone might know it yet.\nWe talked about the goals and non-goals of HPy and basically asked if Python\ncore developers would be willing to participate in HPy design discussions.\nWe discussed PSF endorsement and the conclusion was that we need to talk to\nthe PSF.\nWe had some very good discussions and we also got some valuable feedback.\nOur next steps are now to incorporate this feedback and prepare the PEP to\ncontinue discussions there and gather more feedback.\nWe thank the Python core developers for participating in the call and for the\noffered support.\nCall with NumPy Core Developer Sebastian Berg\nSince we are working on the migration of NumPy to HPy, we had a call with\nSebastian Berg on Tuesday (September 20th, 2022).\nWe discussed some problems we discovered during our migration work and were\ndiscussing how to solve it.\nThese were the main discussion points:\n\n\nNumPy's structured data type allows to have objects in NumPy arrays which\n  problematic for HPy. This is mainly because doesn't allow to use the API\n  during deallocation of an object. Hence, there is no way to determine the\n  location of those objects by fetching the data type (which requires an API\n  call). We discussed to mirror the structure in pure C-level data structures\n  instead.\n\n\nHPy requires to migration all static types to heap types and we discovered\n  that static type behave a bit differently compared to heap types in the case\n  of multiple inheritance. We discussed if that is a bug that CPython needs\n  to solve or if that is something that NumPy should change. So far, it looks\n  rather to be a CPython problem since heap types are pretty new.\n\n\nWe further discussed how to handle NumPy's C API when migrating to HPy. We\n  agreed that we will probably need to provide a separate NumPy HPy C API as\n  well which will maybe removed at some point in future.\n\n\nMain Technical Achievements of the Sprint\n\n\nWe have added support for stack traces when running in the debug mode on Mac\n  OS X (PR 346).\n\n\nWe are up to finish our incremental porting example\n  (PR 246)\n\n\nHPy does now also correctly support object members in HPy types\n  (PR 347).",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2022/09/hpy_sprint_2022_report/"
    },
    {
      "title": "HPy on GraalPy and Matplotlib/HPy",
      "text": "Recently, the\nGraalVM Python team started a series of blog\nposts on Medium about\nHPy on GraalPy\nand about the\nmigration of Matplotlib to HPy\n. The second blog post is in particular interesting since it not only describes\nthe migration process but also shows performance numbers. The source code is\nalso publicly available.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2022/09/hpy_on_graal_and_mpl/"
    },
    {
      "title": "Dusseldorf PyPy/HPy/other sprint Sept 19-23, 2022",
      "text": "I'm happy to announce that we will finally have another PyPy/HPy/other sprint\nin D\u00fcsseldorf, Germany from September 19-23, 2022.\nThe sprint will be located at Heinrich Heine University D\u00fcsseldorf. Many\nthanks to Carl Friedrich for organizing this.\nWe will again follow an open format, i.e., everyone that is interesting in HPy,\nPyPy, or some related topic is welcome to join the sprint.\nSee also the\nannouncement on the PyPy blog.\n\n\nGoals and topics of the sprint\nFrom the HPy point of view, there is no strict agenda. The main goal of the\nsprint is to make progress on HPy in any way you can think of.\nThis includes but is not limited to:\n\nReview, discuss, maybe merge open GitHub PRs.\nHacking on HPy: implement new features, fix bugs, etc.\nCome up with ideas for blog posts or even write blog posts.\nMigrate packages to HPy or just determine candidates for migration.\nDocument the HPy API.\nCreate small documented and tested porting examples and/or a small porting\n    guide.\n\nAccommodation\nWe do not organize an accommodation. A hotel close the campus is the\nHK-Hotel D\u00fcsseldorf but we rather\nrecommend to book something in the city center since we will usually end up\nthere in the evenings. The convenient parts of town are something like\nAltstadt, Stadtmitte, Friedrichstadt, Carlstadt, or Unterbilk.\nRegistration\nThere is no formal registration nor any fee for participation. Just to know who\nwe should expect to show up, please follow the instructions on\nthe PyPy blog.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2022/07/dusseldorf-sprint-2022/"
    },
    {
      "title": "hpy 0.0.4: Third public release",
      "text": "HPy 0.0.4 is out! The third official HPy release comes with many new features\nand was again made available on PyPI.\nMajor highlights of the release are a bunch of new API functions (e.g.\nHPyErr_ExceptionMatches, HPyErr_WarnEx, HPy_Contains, and more),\nPython 3.10 support, better support for native fields (HPyField) and global\nvariables (HPyGlobal), new debug mode features (detect invalid raw data\npointer usage, detect invalid closing of argument handles, detect return of\ninvalid handles).\nGreat news too is that we are now able to provide two more non-trivial projects\nthat have been (partially) migrated to HPy. This is,\nKiwisolver\nand Matplotlib.\n\n\nWhat is HPy?\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>. For more info, look at\nthe\nofficial documentation.\nInstallation\nHPy 0.0.4 is best tested on Linux systems but there is also initial support for\nWindows (both x86_64).\nFor CPython, you need to install it manually, using pip:\n$ pip install hpy==0.0.4\n\n\n\nPyPy and GraalPython already\ncome with intrinsic HPy support, so no installation is necessary. HPy 0.0.4 will\nbe included in the next release of both. In the meantime, you can download a\nnightly or dev build:\n\n\nPyPy nightly builds\n\n\nGraalVM CE dev builds\n\n\nTo check the version of HPy which is shipped with those, you can either use\npip or hpy.universal.get_version():\n$ pypy -m pip show hpy\nName: hpy\nVersion: 0.0.4\n...\n\n$ graalpython -m pip show hpy\nName: hpy\nVersion: 0.0.4\n...\n\n$ pypy -c 'import hpy.universal; print(hpy.universal.get_version()[0])'\n0.0.4\n\n$ graalpython -c 'import hpy.universal; print(hpy.universal.get_version()[0])'\n0.0.4\n\n\n\nAPI\nWe are constantly working on the HPy API and keep adding functions that are\nmissing. We've added following API functions to the new release:\n\nHPyErr_SetFromErrnoWithFilename, HPyErr_SetFromErrnoWithFilenameObjects\nHPyErr_ExceptionMatches\nHPyErr_WarnEx\nHPyErr_WriteUnraisable\nHPy_Contains\nHPyLong_AsVoidPtr\nHPyLong_AsDouble\nHPyUnicode_AsASCIIString, HPyUnicode_DecodeASCII\nHPyUnicode_AsLatin1String, HPyUnicode_DecodeLatin1\nHPyUnicode_DecodeFSDefault, HPyUnicode_DecodeFSDefaultAndSize\nHPyUnicode_ReadChar\n\nFor an overview of the current API, please refer to the public API declaration\nin public_api.h,\nwhich is used to autogenerate parts of the HPy code and is a reliable list of\nall the supported functions. Also have a look at additional helpers in\ninline_helpers.h.\n\nWarning\nThe HPy API is still considered in alpha status and it's subject to change\nbetween versions.\n\nDebug Mode\nWe again improved HPy's debug mode and added following new features:\nEnable Debug Mode via Environment Variable\nThe debug mode can now be enabled using environment variable HPY_DEBUG. It is\npossible to enable the debug mode for all HPy extensions or it is also possible\nto enable it just for certain extensions by enumerating them.\nExample:\n$ # enable debug mode for all HPy extensions\n$ HPY_DEBUG=1 python3 my_application.py\n\n$ # enable debug mode just for ujson_hpy and piconumpy_hpy\n$ HPY_DEBUG=ujson_hpy,piconumpy_hpy python3 my_application.py\n\n\n\nDetect Invalid Use of Raw Data Pointers\nSome API functions return a raw data pointer from an object. For example:\nconst char* HPyUnicode_AsUTF8AndSize(HPyContext *ctx, HPy h, HPy_ssize_t *size)\n\n\n\nreturns a raw data pointer to the UTF8 representation of a Python unicode\nobject. HPy doesn't expose the internal representation of the unicode object, so\nthe Python implementation may use an arbitrary internal representation. This\nmeans that the UTF8 representation is just temporarily created for this API call\nand so the raw data must be released at some point. The contract here is that\nthe raw data pointer is valid as long as the corresponding handle is valid.\nExample:\n#include <string.h>\n\nstatic const char *s_hello_world = \"Hello, World!\";\n\nstatic const char * foo(HPyContext *ctx)\n{\n    HPy h_unicode = HPyUnicode_FromString(ctx, s_hello_word);\n    HPy_ssize_t size;\n    const char *res = HPyUnicode_AsUTF8AndSize(ctx, h_unicode, &size);\n\n    /* closing 'h_unicode' is, of course, correct */\n    HPy_Close(ctx, h_unicode);\n\n    /* raw data pointer 'res' may have become invalid when closing\n       'h_unicode' */\n    return res;\n}\n\nstatic int bar(HPyContext *ctx)\n{\n    const char *s = foo(ctx);\n\n    /* accessing 's' will cause a fatal error in debug mode (on supported\n    systems) */\n    return strcmp(s, s_hello_world) == 0;\n}\n\n\n\nIt is easy to forget about this resriction and if the raw data pointer is used\nafter the handle was closed, it may point to garbage. If the debug mode is\nenabled, it will make the underlying memory inaccessible and every access to the\npointer will then cause a crash of the application. This is currently only\nimplemented for Linux systems. We use a different strategy on other systems and\nfill the pointer with some marker bytes that make it easy to detect.\nDetect Incorrect Closing of Argument Handles\nHPy functions that are called from Python receive handles that are owned by the\ncaller. This means that those handles must not be closed by the callee but it\nis, of course, possible to erroneously call HPy_Close on them. For example:\nHPyDef_METH(foo, \"foo\", foo_impl, HPyFunc_O, .doc=\"closing argument\")\nstatic HPy foo_impl(HPyContext *ctx, HPy self, HPy arg)\n{\n    // error: 'arg' is owned by the caller\n    HPy_Close(ctx, arg);\n    return HPy_Dup(ctx, ctx->h_None);\n}\n\n\n\nDetect Invalid Handles Returned from Function\nA common problem when returning handles is that the author may easily forget to\ncreate a new handle. The debug mode now detects situations like the following:\nHPyDef_METH(foo, \"foo\", foo_impl, HPyFunc_NOARGS, .doc=\"returns arg w/o dupping it\")\nstatic HPy foo_impl(HPyContext *ctx, HPy self)\n{\n    // should be: return HPy_Dup(ctx, self);\n    return self;\n}\n\n\n\nExamples\nBesides the known examples, this is HPy's \n\"proof of concept\" package, \nultrajson-hpy,\npiconumpy, we are\nexcited to present two new packages we have migrated to HPy:\n\n\nKiwi \n    is an efficient C++ implementation of the Cassowary constraint solving\n    algorithm.\n\n\nMatplotlib\n    is a comprehensive library for creating static, animated, and interactive\n    visualizations in Python.\n    Since Matplotlib also has a dependency to NumPy, the migration is not fully\n    finished but luckily, HPy provides the legacy compatibility API such that we\n    can still call legacy C API functions from HPy.\n\n\nWe are still cleaning these ports up and will write another blog post about the\nports and open them for discussion with the project owners.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2022/06/hpy-0.0.4-third-public-release/"
    },
    {
      "title": "hpy 0.0.3: Second public release",
      "text": "HPy 0.0.3 is out! This is already HPy's second officially released version and\nwas again made available on PyPI.\nThe major highlights of this release are new API functions, new debug mode\nfeatures, and Windows support.\n\n\nWhat is HPy?\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>. For more info, look at\nthe\nofficial documentation.\nInstallation\nHPy 0.0.3 is best tested on Linux systems but there is also initial support for\nWindows (both x86_64).\nFor CPython, you need to install it manually, using pip:\n$ pip install hpy==0.0.3\n\n\n\n\nNote\nCurrently, we provide only the sdist (i.e., the .tar.gz, no binary\nwheels). But we plan to ship binary wheels starting with the next release.\n\nPyPy and GraalPython already\ncome with intrinsic HPy support, so no installation is necessary. HPy 0.0.3 is\nincluded in the current releases of both, i.e. PyPy 7.3.6 (released on \n2021-10-17) and GraalPython 21.3.0 (released on 2021-10-19).\nTo double check the version of HPy which is shipped with those, you can either\nuse pip or hpy.universal.get_version():\n$ pypy -m pip show hpy\nName: hpy\nVersion: 0.0.3\n...\n\n$ graalpython -m pip show hpy\nName: hpy\nVersion: 0.0.3\n...\n\n$ pypy -c 'import hpy.universal; print(hpy.universal.get_version()[0])'\n0.0.3\n\n$ graalpython -c 'import hpy.universal; print(hpy.universal.get_version()[0])'\n0.0.3\n\n\n\nAPI\nHPy is still under heavy development and does not yet provide as many API\nfunctions as Python's C API, but more and more pieces are being added.\nIn this release, we've added following functions:\n\nHPy_Is\nHPyBytes_FromStringAndSize\nHPyErr_NewException\nHPyErr_NewExceptionWithDoc\nHPyUnicode_AsUTF8AndSize\nHPyUnicode_DecodeFSDefault\nHPyImport_ImportModule\n\nAll of the above functions except of HPy_Is have equivalents in the C API. You\njust need to remove the leading H from the name.\nFunction HPy_Is was added to be able to do object identity comparisons. In the\nC API, you would just do a pointer comparison like this:\nPyObject *object_a = /* ... */;\nPyObject *object_b = /* ... */;\nreturn object_a == object_b;\n\n\n\nIn HPy, direct comparisons of handles are forbidden by design, because distinct\nhandles can point to the same object. To compare objects by identity, you need\nto use HPy_Is:\nHPy object_a = /* ... */;\nHPy object_b = /* ... */;\nreturn HPy_Is(ctx, object_a, object_b);\n\n\n\nWe've also extended functions HPyArg_Parse and HPyArg_ParseKeywords and\nadded support for format specifier s. The new specifier converts a Python\nunicode object into a C string. For example:\nconst char *result;\nif (!HPyArg_Parse(ctx, NULL, args, nargs, \"s\", &result)) {\n    return HPy_NULL;\n}\nprintf(\"result = %s\\n\", result);\n\n\n\nFor an overview of the current API, please refer to the public API declaration\nin public_api.h,\nwhich is used to autogenerate parts of the HPy code and is a reliable list of\nall the supported functions.\n\nWarning\nThe HPy API is still considered in alpha status and it's subject to change\nbetween versions.\n\nDebug Mode\nOne of the great features of HPy is the debug mode. It was already introduced\na while ago (and therefore already included in release 0.0.2) but it got a new\nfeature that can help C extension developers a lot. HPy's debug mode is now able\nto track closed handles. Previously, it was not guaranteed that accesses to\nclosed handles will cause a fatal error. This is because it's possible that\nanother object is associated with the closed handle. Then the program would just\noperate on the wrong object. The new feature is able to prevent that.\nExamples\nThe best way to get a glimpse of how to use HPy is to look at examples:\n\n\nthe HPy repository contains a\n    \"proof of concept\" package. \n    Make sure to checkout the branch release/0.0.3.\n\n\nultrajson-hpy\n    is a port of the popular ultrajson package. Make sure to checkout the\n    hpy-0.0.3 branch.\n\n\npiconumpy\n    contains a very tiny implementation of an array-like class. Make sure to\n    checkout the hpy-0.0.3 branch.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/10/hpy-0.0.3-second-public-release/"
    },
    {
      "title": "hpy 0.0.2: First public release",
      "text": "HPy 0.0.2 is out! This is the first version which is officially released and\nmade available on PyPI.\nThe major highlight of this release is that it is supported by three different\nPython implementations: CPython, PyPy and GraalPython.\n\n\nWhat is HPy?\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>. For more info, look at\nthe\nofficial documentation.\nInstallation\nHPy 0.0.2 only supports Linux systems, and it's only tested on\nx86_64. Windows support is already present on master, and it will be\nincluded in the next release.\nFor CPython, you need to install it manually, using pip:\n$ pip install hpy==0.0.2\n\n\n\n\nNote\nCurrently, we provide only the sdist (i.e., the .tar.gz, no binary\nwheels). See also\nissue #223, contributions\nare welcome :).\n\nPyPy and GraalPython ships their own version of HPy, so no installation is\nnecessary. HPy 0.0.2 will be included in the next release of both, i.e. PyPy\n7.3.6 (expected in October 2021) and GraalPython 21.2.0 (expected on\n2021-07-20). In the meantime, you can download a nightly build:\n\n\nPyPy 3.7 nightly builds, for example revision 3bf99c09018b\n\n\nGraalPython: download the latest graalpython-dev package from\n    this page\n\n\nTo double check the version of HPy which is shipped with those, you can either\nuse pip or hpy.universal.get_version():\n$ pypy -m pip show hpy\nName: hpy\nVersion: 0.0.2\nSummary: A better C API for Python\nHome-page: https://hpyproject.org\nAuthor: The HPy team\nAuthor-email: hpy-dev@python.org\nLicense: MIT\n...\n\n$ pypy -c 'import hpy.universal; print(hpy.universal.get_version()[0])'\n0.0.2\n\n\n\nAPI\nAt the moment HPy supports only a small fraction of the full API offered by\nthe old Python/C API, but it is enough to write non-trivial extensions, and\nthe documentation is\nscarce. public_api.h,\nwhich is used to autogenerate parts of the HPy code, is a reliable list of all\nthe supported functions.\n\nWarning\nThe HPy API is still considered in alpha status and it's subject to change\nbetween versions. In fact, the current master is already incompatible with\nhpy-0.0.2 because of\nPR #182, which renamed all\noccurences of HPyContext into HPyContext*.\n\nExamples\nThe best way to get a glimpse of how to use HPy is to look at examples:\n\n\nthe HPy repository contains a\n    \"proof of concept\" package. \n    Make sure to checkout the branch release/0.0.2.\n\n\nultrajson-hpy\n    is a port of the popular ultrajson package. Make sure to checkout the\n    hpy-0.0.2 branch.\n\n\npiconumpy\n    contains a very tiny implementation of an array-like class. Make sure to\n    checkout the hpy-0.0.2 branch.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/07/hpy-0.0.2-first-public-release/"
    },
    {
      "title": "#hpy IRC moves to Libera.Chat",
      "text": "Following the example of many other FOSS projects, the HPy team has\ndecided to move its official #hpy IRC channel from Freenode to\nLibera.Chat: irc.libera.chat/hpy\nThe core devs will no longer be present on the Freenode channel, so we recommend to\njoin the new channel as soon as possible.\nwikimedia.org has a\nnice guide on\nhow to setup your client to migrate from Freenode to Libera.Chat.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/05/hpy-irc-moves-to-libera-chat/"
    },
    {
      "title": "HPy @ Python Language Summit",
      "text": "Yesterday I had the privilege to give a talk about HPy\n (sildes) at the\n Python Language Summit 2021.\nThe organizers of the summit will soon publish a full report about the event\n(edit: now available\nhere),\nbut for the HPy-specific\npart,\nwe got generally good feedback. Someone has a few concerns that if CPython is\nto change the API, HPy might not be going far enough. Others said that Python\nshouldn't wait for the \"perfect\" API if HPy can be the \"good\" one that helps it\nevolve.\nEveryone was open to have HPy-compatible wheels on PyPI, once the HPy\nUniversal ABI stays relatively stable. Many people suggested that we should\nreally write a PEP to propose HPy as a \"semi-official\" API for Python.\n\n\nAn interesting question was about which are the VM optimizations which are\ncompatible with the HPy API. The following is a non-exhaustive list of things\nwhich are known to work because they already used by PyPy and/or GraalPython:\n\nJIT compiler\nmoving/compacting GCs\nstorage strategies\nmaps (also known as \"hidden classes\")\n\nOne notable missing optimization from the list above is tagged\npointers. Currently there is no implementation which uses tagged pointers and\nsupports HPy. However, we don't think there is any fundamental design issue in\nHPy which would prevent it: if you turn tagged pointers into \"tagged handles\",\nthings should just work out of the box.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/05/hpy-python-language-summit/"
    },
    {
      "title": "HPy Status Update",
      "text": "HPy's first git commit was on Friday, 12 July 2019. Despite the crazy state\nof the world, HPy has come a long way\nsince then. This is a quick update to say where we are now and what's planned\nfor the immediate future.\n\n\nWhat can one do with HPy right now?\nOne can already port non-trivial Python extensions to the HPy API, but\nthere is also still a lot of work to do. Things one can do right now\nwith HPy include:\n\nInitialize an extension module\nCreate custom extension types\nCreate custom methods and functions\nInteract with many built-in types (including dictionaries, tuples,\n    lists, strings, bytes and longs)\nRaise and check exceptions\nParse arguments to C functions\nCall Python functions\nCompile an extension against either the \"universal\" or \"cpython\" ABIs (see below)\nLoad a single compiled \"universal\" extension into different Python implementations.\nPut a \"universal\" extension into debug mode at runtime (see below\n    for how this is possible without a performance penalty).\nCompile extensions for POSIX and Windows (MSVC).\n\nAn extension written using HPy may be compiled against either the \"cpython\" or\n\"universal\" ABI:\n\n\ncompiling against the \"cpython\" ABI produces an ordinary Python C extension.\n    The extension uses the HPy API only internally. From the point of view of\n    the Python implementation the compiled module is an ordinary C extension\n    that just happens to have been compiled using HPy. Note that as is the case\n    for ordinary C extensions, the modules produced target a specific\n    ABI tag.\n\n\ncompiling against the \"universal\" ABI produces an HPy C extension. This\n    extension does not use the Python C API directly at all and the ABI\n    is unique (up to platform and HPy version number). The same compiled module\n    may thus be loaded by multiple Python versions and implementations.\n    A Python implementation must know how to load such an extension and have\n    implemented the HPy universal ABI. Universal ABI implementations exist for\n    CPython, PyPy and GraalPython.\n\n\nDebug mode is implemented by replacing the HPy context with a debug mode\ncontext at runtime. The debug context wraps the original context and tracks\nall HPy API calls. Debug mode already supports finding handles that are\nleaked (i.e. not closed) and handles that are used after being closed.\nAdditional debug features will be fairly straightforward to add, like for example checking for NULL pointers or detecting whether the user is trying to call a function without holding the GIL.\nThe debug mode is written using HPy itself, so its implementation can be\nshared by different Python implementations that support HPy.\nWhat are the next steps?\nThe big picture is that we're working towards writing a Cython backend\nand porting core features of numpy to HPy. There is still some way to go\nbut the immediate next steps planned are:\n\n\nAdd support for storing long-lived references to other Python objects in\n    custom types, i.e. the equivalent of storing a PyObject * in\n    one of the fields with the struct of a custom type. HPy handles are only for\n    short-lived references, so we need a GC-friendly way to store long-lived\n    references.\n    See issue #9.\n\n\nImplement isolated module level state, to avoid using C static global\n    variables. This will be the HPy equivalent of\n    PEP 573 and\n    PEP 630.\n\n\nImplement multi-phase Python module initialization (HPy currently uses the\n    legacy module initialization).\n    See issue #183.\n\n\nUpdate the PyPy and GraalPython HPy implementations to support all the\n    latest HPy features.\n\n\nStart work on an HPy backend for Cython.\n\n\nContinuing work on a minimal port of numpy's array type to HPy.\n\n\nAsk the CPython core developers whether we can find a way to support\n    HPy universal extensions directly within in CPython (currently we write\n    a small .py file that knows how to load the universal extension, but\n    the presence of this stub file causes many small edge cases that are\n    annoying for HPy developers and users)\n\n\nIf you'd like to work on any of these with us, drop us a note in the\ncomments or mailing list or join us on IRC.\nHappy hacking,\nThe HPy Team.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/05/may-status-update/"
    },
    {
      "title": "Hello, HPy",
      "text": "Welcome to the shiny new HPy blog!\nHPy has been around for a while now. The initial discussion started during\nEuroPython 2019, in the good old times when we could still go to conferences\nand have real-life meetings. Since then, HPy progressed a lot from the\npoint of view of the actual code, but we have been a bit too silent\nw.r.t. communicating what we are doing to the external world and to the broader\nPython community. Hopefully, now that this blog is online we will do a better\njob at periodically communicating the status of HPy, so make sure to\nsubscribe to the RSS feed.\n\n\nWhat is HPy?\nQuoting the frontpage of our website:\n\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>.\n\nThe official Python/C API is\nspecific to the current implementation of CPython: it exposes many\ninternal details which makes it hard:\n\n\nto implement it for other Python implementations (e.g. PyPy, GraalPython,\n    Jython, IronPython, etc.)\n\n\nto experiment with new things inside CPython itself: e.g. using a GC\n    instead of refcounting, or to remove the GIL.\n\nto correctly check things like refcount handling: the external API gets mixed in with implementation details that should be hidden.\n\nOver the years, it has become evident that\nemulating the Python/C API in an efficient way is challenging,\nif not impossible. The main goal of HPy is expose a C API which is possible\nto implement in an efficient way on a number of very diverse Python\nimplementations.\nThere are several advantages to writing your C extension in HPy:\n\n\nit runs much faster on PyPy, and at native speed on CPython\n\n\nit is possible to compile a single binary which runs unmodified on all\n    supported Python implementations and versions\n\n\nit is simpler and more manageable than the Python/C API\n\n\nit provides an improved debugging experience: in \"debug mode\", HPy\n    actively checks for many common mistakes such as reference leaks and\n    invalid usage of objects after they have been deleted. It is possible to\n    turn the \"debug mode\" on at startup time, without needing to recompile\n    Python or the extension itself\n\n\nSee also the official docs for a more in-depth\noverview.\nShow me an example\nThis is a \"normal\" Python/C extension:\n2021/03/hello-hpy/hello_old.c  (Source)#include <Python.h>\n\nstatic PyObject* add(PyObject* self, PyObject* args) {\n    long a, b;\n    if (!PyArg_ParseTuple(args, \"ll\", &a, &b))\n        return NULL;\n    return PyLong_FromLong(a+b);\n}\n\nstatic PyMethodDef HelloMethods[] = {\n    {\"add\", (PyCFunction)add, METH_VARARGS, \"add two integers\"},\n    {NULL, NULL, 0, NULL}\n};\n\nstatic struct PyModuleDef moduledef = {\n    PyModuleDef_HEAD_INIT,\n    \"hello_old\",\n    \"hello example using the old Python/C API\",\n    -1,\n    HelloMethods,\n};\n\nPyMODINIT_FUNC\nPyInit_hello_old(void) {\n    return PyModule_Create(&moduledef);\n}\n\n\nWe can compile it with a simple setup.py:\nfrom setuptools import setup, Extension\nsetup(\n    name=\"hello\",\n    ext_modules = [\n        Extension('hello_old', ['hello_old.c']),\n    ],\n)\n\n\n\n$ python setup.py build_ext --inplace\n...\n$ python \n>>> import hello_old\n>>> hello_old.add(10, 20)\n30\n\n\n\nNow, let's start to uncover the HPy equivalent, piece by piece:\n#include <hpy.h>\n\nHPyDef_METH(add, \"add\", add_impl, HPyFunc_VARARGS,\n            .doc = \"add two integers\");\n\nstatic HPy add_impl(HPyContext ctx, HPy self, HPy *args, HPy_ssize_t nargs) {\n    long a, b;\n    if (!HPyArg_Parse(ctx, NULL, args, nargs, \"ll\", &a, &b))\n        return HPy_NULL;\n    return HPyLong_FromLong(ctx, a+b);\n}\n\n\n\nThere are a bunch of things which are different from the usual C-extension module:\n\n\nthe former PyObject * is now HPy, which we call \"a handle\". Handles are\n  similar to PyObject *, but are completely opaque: for more information,\n  see the\n  official docs.\n\n\nThere is an additional parameter, HPyContext ctx. One of the problems of\n  the old API is that often it implicitly relies on the existence of a\n  per-thread or per-subinterpreter local state. HPyContext makes this state explicit. This\n  makes the whole API more regular and makes it possible to develop new\n  interesting features such as the\n  Universal ABI\n  and the Debug mode.\n\n\nHPy introduces the concept of HPyDefs. HPyDef_METH is a macro which\n  generates the definition of an HPyDef static constant named add, which\n  represents the definition of a Python method implemented by the C function\n  add_impl. In this specific example HPyDef_METH contains more or less the\n  same informations as the old PyMethodDef, but HPyDef are more\n  general. For example, when defining custom types you can use things like\n  HPyDef_SLOT, HPyDef_GETSET, etc.\n\n\nNotice that we no longer need the cast to (PyCFunction). One of the\n  biggest advantages of HPyDef_METH is that since it's a macro, it can\n  automatically generate a forward declaration for add_impl, with the\n  correct signature. This means that if you use the wrong number and/or type\n  of parameters, you get a nice compile-time error instead of an obscure crash\n  at runtime.\n\n\nThe signature corresponding to HPyFunc_VARARGS is slighly different than\n  the old METH_VARARGS: we pass positional arguments as a C array instead of\n  a Python tuple. This means that it is possible to call the function without\n  having to allocate a Python tuple, and for example the PyPy implementation\n  of HPy takes advantage of that. This is very similar to CPython's\n  VectorCall protocol.\n\n\n\nNote\nIn this post, we are using a slightly old version of HPy. If you try with\na newer version you should use HPyContext *ctx instead of HPyContext ctx.\nSee also Issue #150\nand PR #182.\n\nLet's continue our tour of hello_new.c:\nstatic HPyDef *hello_defines[] = {\n    &add,\n    NULL\n};\n\nstatic HPyModuleDef moduledef = {\n    HPyModuleDef_HEAD_INIT,\n    .m_name = \"hello_new\",\n    .m_doc = \"hello example using the new HPy API\",\n    .m_size = -1,\n    .defines = hello_defines,\n};\n\nHPy_MODINIT(hello_new)\nstatic HPy init_hello_new_impl(HPyContext ctx) {\n    return HPyModule_Create(ctx, &moduledef);\n}\n\n\n\nThis is pretty similar to the old code. The biggest change is that instead of\ndeclaring an array of PyMethodDef, we create an array of HPyDef as\ndiscussed above.\nFinally, we need to modify setup.py. Compiling an HPy extension is as easy\nas adding setup_requires=['hpy.devel'] and use hpy_ext_modules:\n2021/03/hello-hpy/setup.py  (Source)from setuptools import setup, Extension\nsetup(\n    name=\"hello\",\n    ext_modules = [\n        Extension('hello_old', ['hello_old.c']),\n    ],\n    hpy_ext_modules = [\n        Extension('hello_new', ['hello_new.c']),\n    ],\n    setup_requires=['hpy.devel'],\n)\n\n\nCompiling HPy extensions\nIn this demo, we will show how to setup an environment to try HPy and compile\nextensions on both CPython and PyPy.\nAt the moment HPy is still in its early stages and the API is still subject to\nchange, so we have not done any official release yet. For the same reason, if\nyou want to use HPy on PyPy or GraalPython, you need to manually ensure to install\na version which is supported. This is just temporary, and this kind of things will\nbe sorted out automatically once we start to roll out official releases.\nSo, we need to install HPy from the github repo. Moreover, the HPy\nimplementations inside PyPy and GraalPython are lagging behind a little, so we will\ninstall a slightly old revision:\n\n\nHPy revision eb07982\n\n\nnightly build of the PyPy hpy branch: a2f7c80062e8 for linux64\n\n\nPyPy nighly builds: main page and\n  hpy branch\n\n\nGraalPython nightly build: Linux or macOS\n\n\nsource code of this example\n\n\nThe first step is to create a venv for CPython and install hpy:\n$ python3 -m venv tryhpy\n$ . tryhpy/bin/activate\n$ pip install wheel\n$ pip install git+git://github.com/hpyproject/hpy.git@eb07982\n\n\n\nTo install a nightly build of PyPy it is enough to unpack the tarball and run\n-m ensurepip. We can check what is the HPy version supported by PyPy by\ncalling hpy.universal.get_version():\n$ curl -O http://buildbot.pypy.org/nightly/hpy/pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2\n$ tar xf pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2\n$ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy -m ensurepip\n\n$ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy\n>>>> import hpy.universal\n>>>> hpy.universal.get_version()\n('0.1.dev959+geb07982', 'eb07982')\n\n\n\nFor GraalPython, just unpack the tarball and create a venv:\n$ curl -LO https://github.com/graalvm/graalvm-ce-dev-builds/releases/download/21.1.0-dev-20210330_0726/graalpython-dev-linux-amd64.tar.gz\n$ tar xzf graalpython-dev-linux-amd64.tar.gz\n$ graalpython-21.1.0-dev-linux-amd64/bin/graalpython -m venv hpy-venv\n$ hpy-venv/bin/graalpython\n>>> import hpy.universal\n>>> hpy.universal.get_version()\n>>> ('0.1.dev950+g98f448a', '98f448a')\n\n\n\nNow that our enviroment is ready, we can compile and try our extensions:\n$ cd /path/to/example/\n$ . /path/to/tryhpy/bin/activate    # activate the venv\n$ python setup.py build_ext --inplace\n[...]\n\n$ ls -1 *.so\nhello_new.cpython-38-x86_64-linux-gnu.so\nhello_old.cpython-38-x86_64-linux-gnu.so\n\n$ python\n>>> import hello_old, hello_new\n>>> hello_old.add(10, 20)\n30\n>>> hello_new.add(30, 40)\n70\n>>>\n\n\n\nIt worked! One important thing to note is the filename of hello_new:\n.cpython-38-x86_64-linux-gnu.so is the standard filename for CPython 3.8\nextension modules. This happens because by default hpy_ext_modules targets\nthe\nCPython ABI. As\nsuch, from the point of view of CPython hello_new is indistinguishable from\nhello_old. It also means that HPy is required only to compile it but not to\nimport it later. Finally, we expect the performance to be the very same as the\nextensions using the old API.\nHowever, we can also explicitly ask HPy to produce an \"universal binary\",\nwhich targets the\nHPy Universal ABI:\nas the name implies, universal binaries can be imported by CPython, but also\nby alternative implementations such as PyPy. We can build universal binaries\nby passing --hpy-abi=universal to setup.py:\n$ # clean the previous build\n$ rm -rf build/ *.so\n\n$ python setup.py --hpy-abi=universal build_ext --inplace\n$ ls -1 *.so\nhello_new.hpy.so\nhello_old.cpython-38-x86_64-linux-gnu.so\n\n\n\nNote the filename: hello_old is still a CPython-specific extension, but\nhello_new.hpy.so is an universal binary. Once compiled, you can import it as\nusual:\n$ python\n>>> import hello_old, hello_new\n>>> hello_old.add(10, 20)\n30\n>>> hello_new.add(30, 40)\n70\n>>> hello_new.__file__\n'/.../hello-hpy/hello_new.hpy.so'\n\n\n\n\nNote\nAt the moment of writing, because of\nIssue #191 if you try to\nprint the repr of hello_new, you see something like this (note the .py\nextension):\n>>> hello_new\n<module 'hello_new' from '/.../hello-hpy/hello_new.py'>\n\n\n\n\nNote that on its own, CPython does not know how to import .hpy.so\nfiles. The magic is done by the hello_new.py, which is automatically\ngenerated by setup.py:\n$ cat hello_new.py\n[...]\ndef __bootstrap__():\n    [...]\n    from hpy.universal import load_from_spec\n    ext_filepath = pkg_resources.resource_filename(__name__, 'hello_new.hpy.so')\n    m = load_from_spec(Spec('hello_new', ext_filepath))\n    [...]\n    sys.modules[__name__] = m\n\n__bootstrap__()\n\n\n\nFinally, we can try to import our shiny new universal binary on PyPy:\n$ /path/to/pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy\n>>>> import hello_new\n>>>> hello_new.add(10, 20)\n30\n>>>> hello_new.__file__\n'/.../hello-hpy/hello_new.hpy.so'\n>>>>\n\n\n\nSimilarly, it also just works on GraalPython:\n$ /path/to/graalpython/hpy-venv/bin/graalpython\n>>> import hello_new\n>>> hello_new.add(10, 20)\n30\n\n\n\nThat's all you need to get started with HPy. What we presented today is just\nthe basics, of course: in the next posts we will dig more into the technical\ndetails, and show more interesting features than just a hello world.\nStay tuned!\n(edited on 2021-03-31 to include GraalPython)",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/03/hello-hpy/"
    },
    {
      "title": "HPy - A better C API for Python",
      "text": "What is HPy?\nHPy provides a new API for extending Python in C.  In other words, you use\n#include <hpy.h> instead of #include <Python.h>.\n\n\nWhat are the advantages of HPy?\n\nZero overhead on CPython: extensions written in HPy run at the same\nspeed as \"normal\" extensions.\nMuch faster on alternative implementations such as PyPy, GraalPython.\nUniversal binaries: extensions built for the HPy Universal ABI can be\nloaded unmodified on CPython, PyPy, GraalPython, etc.\nA migration path for mixing legacy C-API calls with HPy API calls. Once\nall the code is migrated, the extension can be compiled as a universal binary\nthat works on any CPython version, PyPy, or GraalPy.\nDebug mode: in debug mode, you can easily identify common problems such\nas memory leaks, invalid lifetime of objects, invalid usage of APIs. Have\nyou ever forgot a Py_INCREF or Py_DECREF? The HPy debug mode can be\nactivated at runtime to detect these mistakes for you on universal binaries.\nNicer API: the standard Python/C API shows its age. HPy is designed to\novercome some of its limitations, be more consistent, produce better quality\nextensions and to make it harder to introduce bugs.\nEvolvability: As nicely summarized in\n[PEP-620](https://peps.python.org/pep-0620/) the standard Python/C API\nexposes a lot of internal implementation details which makes it hard to\nevolve the C API. HPy doesn't have this problem because all internal\nimplementation details are hidden.\n\n\n\nCurrent status and where we need help\nHPy is in development. 0.0.4 is the latest alpha release.\nWe welcome your design input or adventurous alpha testing.\nThe Python/C API is huge. At the moment many popular functions are\navailable.  Is something missing for the port of your favorite extension?\nPlease open an issue or even better a PR.\nDocumentation could use improvement. Who better to suggest and implement\nimprovements than new users? The reference documentation lives together with\nthe code. We could also use help repurposing notes from the design discussions\nand creating clearer documentation. If this non-coding work is something you\ncan do, let us know.\nTooling and packaging are no less difficult than managing low-level APIs. We\ncould use help driving discussion and implementing:\n\nHow to package a universal extension and how to put it on PyPI?\nHow best to package HPy itself\nHow does HPy integrate with setuptools, mesonpy, or other build systems\nUpstreaming completed forks of the packages listed below, or upstreaming\nparts of the forks so the code does not suffer from bit-rot\n\n\n\nHPy-compatible extensions\nThe extensions that we are experimenting with include:\n\nultrajson-hpy: this was the first real-world module to be ported to HPy. It is\na nice fit because it only exports functions (as opposed as custom types)\nand requires only a small number of API functions.\npiconumpy: as the name suggests, this is a minimal numpy-like module which\ndefines a custom type (similar to ndarray but with many fewer features of\ncourse).\nnumpy: one of our ambitious goals is to port numpy to HPy, and to use this\nexperience to better understand how to design the API. This builds but does\nnot pass the test suite.\nmatplotlib: Since Matplotlib also has a dependency to NumPy, the migration\nto universal mode is not fully finished. HPy provides the legacy compatibility API\nsuch that we can still call legacy C API functions from HPy and successfully\nrun the test suite.\nkiwi-solver: A dependency of Matplotlib, it has been fully ported to\nuniversal mode.\n\nBenchmarks and more information about the Matplotlib and kiwi-solver ports can\nbe found in the GraalVM blog post. The benchmarks show that the HPy ports\nhave little impact on CPython performance, while enabling close-to-cpython\nperformance with GraalVM Python for the kiwi-solver complete HPy port.\n\n\nThis website and the logo are ugly\nWe know: we have expertise in Virtual Machines, Compilers, low-level\nprogramming, etc, but zero expertise in web development or graphic\ndesign. PRs are welcome ;)\n\n\nMore info\n\nDocumentation\nHPy blog\nGithub repository\n#hpy IRC channel\nMailing list\nHPy is pronounced /h/ - pie (or using IPA notation: /e\u026at\u0283-pa\u026a/)\n\n\n\nRecent blog posts\n\n\n    \n            \n            2022-09-26 10:00\n            \u00a0\n            HPy Sprint Status Update and Feedback Session\n            \n            \n            2022-09-08 15:30\n            \u00a0\n            HPy on GraalPy and Matplotlib/HPy\n            \n            \n            2022-07-29 10:00\n            \u00a0\n            Dusseldorf PyPy/HPy/other sprint Sept 19-23, 2022\n            \n            \n            2022-06-02 09:15\n            \u00a0\n            hpy 0.0.4: Third public release\n            \n            \n            2021-10-22 15:00\n            \u00a0\n            hpy 0.0.3: Second public release",
      "tags": "",
      "url": "https://hpyproject.org/"
    }
  ]
};